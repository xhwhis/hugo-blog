<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Posts | Whis&#39;s Blog</title>
<meta name="keywords" content="">
<meta name="description" content="Posts - Whis&#39;s Blog">
<meta name="author" content="">
<link rel="canonical" href="https://xhwhis.github.io/hugo-blog/posts/">
<link crossorigin="anonymous" href="/hugo-blog/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css" integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://xhwhis.github.io/hugo-blog/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://xhwhis.github.io/hugo-blog/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://xhwhis.github.io/hugo-blog/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://xhwhis.github.io/hugo-blog/apple-touch-icon.png">
<link rel="mask-icon" href="https://xhwhis.github.io/hugo-blog/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="https://xhwhis.github.io/hugo-blog/posts/index.xml">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Posts" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://xhwhis.github.io/hugo-blog/posts/" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Posts"/>
<meta name="twitter:description" content=""/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://xhwhis.github.io/hugo-blog/posts/"
    }
  ]
}
</script>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://xhwhis.github.io/hugo-blog/" accesskey="h" title="Whis&#39;s Blog (Alt + H)">Whis&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header">
  <h1>
    Posts
  </h1>
</header>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>socket<sup><span class="entry-isdraft">&nbsp;&nbsp;[draft]</span></sup>
    </h2>
  </header>
  <div class="entry-content">
    <p>我们深谙信息交流的价值，那网络中进程之间如何通信，如我们每天打开浏览器浏览网页时，浏览器的进程怎么与 web 服务器通信的？当你用 QQ 聊天时，QQ 进程怎么与服务器或你好友所在的 QQ 进程通信？这些都得靠 socket？那什么是 socket？socket 的类型有哪些？还有 socket 的基本函数，这些都是本文想介绍的。本文的主要内容如下：
1、网络中进程之间如何通信？ 2、Socket 是什么？ 3、socket 的基本操作 3.1、socket()函数 3.2、bind()函数 3.3、listen()、connect()函数 3.4、accept()函数 3.5、read()、write()函数等 3.6、close()函数 4、socket 中 TCP 的三次握手建立连接详解 5、socket 中 TCP 的四次握手释放连接详解 1、网络中进程之间如何通信？ 本地的进程间通信（IPC）有很多种方式，但可以总结为下面 4 类：
消息传递（管道、FIFO、消息队列） 同步（互斥量、条件变量、读写锁、文件和写记录锁、信号量） 共享内存（匿名的和具名的） 远程过程调用（Solaris 门和 Sun RPC） 但这些都不是本文的主题！我们要讨论的是网络中进程之间如何通信？首要解决的问题是如何唯一标识一个进程，否则通信无从谈起！在本地可以通过进程 PID 来唯一标识一个进程，但是在网络中这是行不通的。其实 TCP/IP 协议族已经帮我们解决了这个问题，网络层的“ip 地址”可以唯一标识网络中的主机，而传输层的“协议&#43;端口”可以唯一标识主机中的应用程序（进程）。这样利用三元组（ip 地址，协议，端口）就可以标识网络的进程了，网络中的进程通信就可以利用这个标志与其它进程进行交互。
使用 TCP/IP 协议的应用程序通常采用应用编程接口：UNIX BSD 的套接字（socket）和 UNIX System V 的 TLI（已经被淘汰），来实现网络进程之间的通信。就目前而言，几乎所有的应用程序都是采用 socket，而现在又是网络时代，网络中进程通信是无处不在，这就是我为什么说“一切皆 socket”。
2、什么是 Socket？ 上面我们已经知道网络中的进程是通过 socket 来通信的，那什么是 socket 呢？socket 起源于 Unix，而 Unix/Linux 基本哲学之一就是“一切皆文件”，都可以用“打开 open –&gt; 读写 write/read –&gt; 关闭 close”模式来操作。我的理解就是 Socket 就是该模式的一个实现，socket 即是一种特殊的文件，一些 socket 函数就是对其进行的操作（读/写 IO、打开、关闭），这些函数我们在后面进行介绍。...</p>
  </div>
  <footer class="entry-footer"><span title='2022-03-27 22:59:11 +0800 +0800'>March 27, 2022</span></footer>
  <a class="entry-link" aria-label="post link to socket" href="https://xhwhis.github.io/hugo-blog/posts/socket/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>STL<sup><span class="entry-isdraft">&nbsp;&nbsp;[draft]</span></sup>
    </h2>
  </header>
  <div class="entry-content">
    <p>Interview Q&amp;A STL B 树（B-tree）、B&#43; 树（B&#43;-tree） 特点 一般化的二叉查找树（binary search tree） “矮胖”，内部（非叶子）节点可以拥有可变数量的子节点（数量范围预先定义好） 应用 大部分文件系统、数据库系统都采用 B 树、B&#43;树作为索引结构 区别 B&#43;树中只有叶子节点会带有指向记录的指针（ROWID），而 B 树则所有节点都带有，在内部节点出现的索引项不会再出现在叶子节点。 B&#43;树中所有叶子节点都是通过指针连接在一起，而 B 树不会。 B 树的优点 对于在内部节点的数据，可直接得到，不必根据叶子节点来定位。 B&#43;树的优点 非叶子节点不会带上 ROWID，这样，一个块中可以容纳更多的索引项，一是可以降低树的高度。二是一个内部节点可以定位更多的叶子节点。 叶子节点之间通过指针来连接，范围扫描将十分简单，而对于 B 树来说，则需要在叶子节点和内部节点不停的往返移动。 STL 容器 容器 底层数据结构 时间复杂度 有无序 可不可重复 其他 array 数组 随机读改 O(1) 无序 可重复 支持随机访问 vector 数组 随机读改、尾部插入、尾部删除 O(1) 头部插入、头部删除 O(n) 无序 可重复 支持随机访问 deque 双端队列 头尾插入、头尾删除 O(1) 无序 可重复 一个中央控制器 &#43; 多个缓冲区，支持首尾快速增删，支持随机访问 forward_list 单向链表 插入、删除 O(1) 无序 可重复 不支持随机访问 list 双向链表 插入、删除 O(1) 无序 可重复 不支持随机访问 stack deque / list 顶部插入、顶部删除 O(1) 无序 可重复 deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时 queue deque / list 尾部插入、头部删除 O(1) 无序 可重复 deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时 priority_queue vector &#43; max-heap 插入、删除 O(log2n) 有序 可重复 vector 容器&#43;heap 处理规则 set 红黑树 插入、删除、查找 O(log2n) 有序 不可重复 multiset 红黑树 插入、删除、查找 O(log2n) 有序 可重复 map 红黑树 插入、删除、查找 O(log2n) 有序 不可重复 multimap 红黑树 插入、删除、查找 O(log2n) 有序 可重复 unordered_set 哈希表 插入、删除、查找 O(1) 最差 O(n) 无序 不可重复 unordered_multiset 哈希表 插入、删除、查找 O(1) 最差 O(n) 无序 可重复 unordered_map 哈希表 插入、删除、查找 O(1) 最差 O(n) 无序 不可重复 unordered_multimap 哈希表 插入、删除、查找 O(1) 最差 O(n) 无序 可重复 </p>
  </div>
  <footer class="entry-footer"><span title='2022-03-27 22:59:11 +0800 +0800'>March 27, 2022</span></footer>
  <a class="entry-link" aria-label="post link to STL" href="https://xhwhis.github.io/hugo-blog/posts/stl/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>swift学习note<sup><span class="entry-isdraft">&nbsp;&nbsp;[draft]</span></sup>
    </h2>
  </header>
  <div class="entry-content">
    <p>Swift 学习 note Swift 引入 使用 import 语句来引入任何的 Objective-C 框架（或 C 库）到 Swift 程序中。例如 import cocoa 语句导入了使用了 Cocoa 库和 API，可以在 Swift 程序中使用它们。
Cocoa 本身由 Objective-C 语言写成，Objective-C 又是 C 语言的严格超集，所以在 Swift 应用中可以很简单的混入 C 语言代码，甚至是 C&#43;&#43; 代码。
分号 Swift 不要求在每行语句的结尾使用分号(;)，但在同一行书写多条语句时，必须用分号隔开：
import Cocoa var str = &#34;Hello World&#34;; print (str) 词法分析或语法分析时应该直接忽略了分号(;)
标识符 如果一定要使用关键字作为标识符，可以在关键字前后添加重音符号（`），例如：
let `class` = &#34;Runoob&#34; 比 php 中的标识符前加@的处理更高级
Swift 空格 Swift 语言并不是像 C/C&#43;&#43;，Java 那样完全忽视空格，Swift 对空格的使用有一定的要求，但是又不像 Python 对缩进的要求那么严格。
在 Swift 中，运算符不能直接跟在变量或常量的后面。例如下面的代码会报错：
let a=1 &#43; 2 错误信息是：...</p>
  </div>
  <footer class="entry-footer"><span title='2022-03-27 22:59:11 +0800 +0800'>March 27, 2022</span></footer>
  <a class="entry-link" aria-label="post link to swift学习note" href="https://xhwhis.github.io/hugo-blog/posts/swift%E5%AD%A6%E4%B9%A0note/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>swift学习note——高级篇<sup><span class="entry-isdraft">&nbsp;&nbsp;[draft]</span></sup>
    </h2>
  </header>
  <div class="entry-content">
    <p>Swift 学习 note——高级篇
Swift 闭包
语法
以下定义了一个接收参数并返回指定类型的闭包语法：
{(parameters) -&gt; return type in statements } 实例
import Cocoa let divide = {(val1: Int, val2: Int) -&gt; Int in return val1 / val2 } let result = divide(200, 20) print (result) 闭包表达式
闭包表达式是一种利用简洁语法构建内联闭包的方式。 闭包表达式提供了一些语法优化，使得撰写闭包变得简单明了
sorted 方法
Swift 标准库提供了名为 sorted(by:) 的方法，会根据您提供的用于排序的闭包函数将已知类型数组中的值进行排序。
排序完成后，sorted(by:) 方法会返回一个与原数组大小相同，包含同类型元素且元素已正确排序的新数组。原数组不会被 sorted(by:) 方法修改。
sorted(by:)方法需要传入两个参数：
已知类型的数组 闭包函数，该闭包函数需要传入与数组元素类型相同的两个值，并返回一个布尔类型值来表明当排序结束后传入的第一个参数排在第二个参数前面还是后面。如果第一个参数值出现在第二个参数值前面，排序闭包函数需要返回 true，反之返回 false 实例
import Cocoa let names = [&#34;AT&#34;, &#34;AE&#34;, &#34;D&#34;, &#34;S&#34;, &#34;BE&#34;] // 使用普通函数(或内嵌函数)提供排序功能,闭包函数类型需为(String, String) -&gt; Bool。 func backwards(s1: String, s2: String) -&gt; Bool { return s1 &gt; s2 } var reversed = names....</p>
  </div>
  <footer class="entry-footer"><span title='2022-03-27 22:59:11 +0800 +0800'>March 27, 2022</span></footer>
  <a class="entry-link" aria-label="post link to swift学习note——高级篇" href="https://xhwhis.github.io/hugo-blog/posts/swift%E5%AD%A6%E4%B9%A0note%E9%AB%98%E7%BA%A7%E7%AF%87/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>vim查找&amp;替换<sup><span class="entry-isdraft">&nbsp;&nbsp;[draft]</span></sup>
    </h2>
  </header>
  <div class="entry-content">
    <p>vim 中的查找与替换 1.查找 在 normal 模式下按下/即可进入查找模式，输入要查找的字符串并按下回车。 Vim 会跳转到第一个匹配。按下n查找下一个，按下N查找上一个。
Vim 查找支持正则表达式，例如/vim$匹配行尾的&#34;vim&#34;。 需要查找特殊字符需要转义，例如/vim\$匹配&#34;vim$&#34;。
2.大小写敏感查找 在查找模式中加入\c表示大小写不敏感查找，\C表示大小写敏感查找。例如：
/foo\c 将会查找所有的&#34;foo&#34;,&#34;FOO&#34;,&#34;Foo&#34;等字符串。
3.大小写敏感配置 Vim 默认采用大小写敏感的查找，为了方便我们常常将其配置为大小写不敏感：
&#34; 设置默认进行大小写不敏感查找 set ignorecase &#34; 如果有一个大写字母，则切换到大小写敏感查找 set smartcase 将上述设置粘贴到你的~/.vimrc，重新打开 Vim 即可生效
4.查找当前单词 在 normal 模式下按下*即可查找光标所在单词（word）， 要求每次出现的前后为空白字符或标点符号。例如当前为foo， 可以匹配foo bar中的foo，但不可匹配foobar中的foo。 这在查找函数名、变量名时非常有用。
按下g*即可查找光标所在单词的字符序列，每次出现前后字符无要求。 即foo bar和foobar中的foo均可被匹配到。
5.查找与替换 :s（substitute）命令用来查找和替换字符串。语法如下：
:{作用范围}s/{目标}/{替换}/{替换标志} 例如:%s/foo/bar/g会在全局范围(%)查找foo并替换为bar，所有出现都会被替换（g）
6.作用范围 作用范围分为当前行、全文、选区等等。
当前行：
:s/foo/bar/g 全文：
:%s/foo/bar/g 选区，在 Visual 模式下选择区域后输入:，Vim 即可自动补全为 :&#39;&lt;,&#39;&gt;。
:&#39;&lt;,&#39;&gt;s/foo/bar/g 2-11 行：
:5,12s/foo/bar/g 当前行.与接下来两行&#43;2：
:.,&#43;2s/foo/bar/g 替换标志 上文中命令结尾的g即是替换标志之一，表示全局global替换（即替换目标的所有出现）。 还有很多其他有用的替换标志：
空替换标志表示只替换从光标位置开始，目标的第一次出现：
:%s/foo/bar i表示大小写不敏感查找，I表示大小写敏感：
:%s/foo/bar/i # 等效于模式中的\c（不敏感）或\C（敏感） :%s/foo\c/bar c表示需要确认，例如全局查找&#34;foo&#34;替换为&#34;bar&#34;并且需要确认：...</p>
  </div>
  <footer class="entry-footer"><span title='2022-03-27 22:59:11 +0800 +0800'>March 27, 2022</span></footer>
  <a class="entry-link" aria-label="post link to vim查找&amp;替换" href="https://xhwhis.github.io/hugo-blog/posts/vim%E6%9F%A5%E6%89%BE-%E6%9B%BF%E6%8D%A2/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>wps实习四个月后<sup><span class="entry-isdraft">&nbsp;&nbsp;[draft]</span></sup>
    </h2>
  </header>
  <div class="entry-content">
    <p>wps 实习四个月后的一些思考和新规划 wps 的实习已经告一段落，玩了一段时间，迷茫了一段时间，整理代码一段时间，现在写一篇思考。
wps 实习内容 在 wps mac 组实习四个月，接手的需求有：
移植 pc 功能 Excel 批量计算 交互功能 空格键进入图片预览 双指滑动（滚轮）移动图片 双指拍&amp;双指捏缩放图片 双指旋旋转 wps 对象 双指/右键拖复制 wps 对象 优化需求 多级窗口 modal 规范 新建文本框默认设置添加选项 复制图片清晰度优化 Excel 单个单元格复制形式改为纯文本 半成品需求 光标 icon 替换为高清图 Excel 底部 sheet 平滑移动 文本框添加只复制文本功能 三指捏需求 感觉这些需求都挺无聊的，所以才交给一个实习生写吧。多级窗口 modal 规范，该需求阅读了大量 qt 源码。触控板扩展需求考察了一堆开源代码，学习了 objective-c 和 swift。也就这两个需求有点意思。
实习过程技术成长 刚入职先学习公司代码规范、工程规范，和一些工作流程。第一次用到心心念念的 mac，也花了点时间来熟悉，用过很多发行版 Linux，上手 mac 也很快。wps 产品由用 qt&#43;c/cpp 完成，技术方面先学习 qt。第一个需求移植 pc 已有的 Excel 批量计算功能，需要添加的代码都在一起，不需要调试，直接上手敲码就好，qt 方面也只需要学习 dialog 的创建，和事件的处理。第二个需求空格键进入图片预览，该有的 api 都有，但需要找到适合修改的代码块，因为不会调试所以花了一个多星期，还是最后组长教会了我调试来定位代码和了解功能的执行流程。后面都是一些调 api 的需求，以及学会 qt 某部分的使用就能写的需求。多级窗口 modal 规范需求，考察了很久才定位到 qt 的 bug（pc 没问题，mac 有问题，应该第一时间就测试一下是不是 qt 的 bug），为解决 bug 阅读了大量 qt 源码，对 qt 的一些特性有了更深了了解，学习框架还是得直接读源码。qt 源码面向对象，以 c&#43;&#43;11 为标准（qt6 以 c&#43;&#43;17 为标准），范型编程到处都是，可读性很好，比 wps 代码好的多。离职前的需求是 mac 触控板相关的，网上资料很少，只有 github 上有几个项目，为了看懂代码就去学了 objective-c，顺便学了 swift（语法方面 c/cpp yyds，oc 真反人类，swift 也习惯不了）。做了一些考察才知道 apple 有 Private API 这个东西，mac 触控板增强软件都用了这部分 api，wps 不可能用的，产品的一些需求也就得打回了。不用写多指需求了，但多指滑、多指捏在继续考察，应该可以通过触控点的坐标识别手势，但自定义手势多了可能就不能做到精准识别了。...</p>
  </div>
  <footer class="entry-footer"><span title='2022-03-27 22:59:11 +0800 +0800'>March 27, 2022</span></footer>
  <a class="entry-link" aria-label="post link to wps实习四个月后" href="https://xhwhis.github.io/hugo-blog/posts/wps%E5%AE%9E%E4%B9%A0%E5%9B%9B%E4%B8%AA%E6%9C%88%E5%90%8E/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>后端开发面试题<sup><span class="entry-isdraft">&nbsp;&nbsp;[draft]</span></sup>
    </h2>
  </header>
  <div class="entry-content">
    <p>后端开发面试题 后端开发面试知识点大纲： 语言类（C&#43;&#43;）： 关键字作用解释： volatile 作用
Volatile关键词的第一个特性：易变性。所谓的易变性，在汇编层面反映出来，就是两条语句，下一条语句不会直接使用上一条语句对应的volatile变量的寄存器内容，而是重新从内存中读取。 Volatile关键词的第二个特性：“不可优化”特性。volatile告诉编译器，不要对我这个变量进行各种激进的优化，甚至将变量直接消除，保证程序员写在代码中的指令，一定会被执行。 Volatile关键词的第三个特性：”顺序性”，能够保证Volatile变量间的顺序性，编译器不会进行乱序优化。 C/C&#43;&#43; Volatile变量，与非Volatile变量之间的操作，是可能被编译器交换顺序的。C/C&#43;&#43; Volatile变量间的操作，是不会被编译器交换顺序的。哪怕将所有的变量全部都声明为volatile，哪怕杜绝了编译器的乱序优化，但是针对生成的汇编代码，CPU有可能仍旧会乱序执行指令，导致程序依赖的逻辑出错，volatile对此无能为力 针对这个多线程的应用，真正正确的做法，是构建一个happens-before语义。 [C/C&#43;&#43; Volatile关键词深度剖析](http://hedengcheng.com/?p=725) static
控制变量的存储方式和可见性。 (1)修饰局部变量 一般情况下，对于局部变量是存放在栈区的，并且局部变量的生命周期在该语句块执行结束时便结束了。但是如果用static进行修饰的话，该变量便存放在静态数据区，其生命周期一直持续到整个程序执行结束。但是在这里要注意的是，虽然用static对局部变量进行修饰过后，其生命周期以及存储空间发生了变化，但是其作用域并没有改变，其仍然是一个局部变量，作用域仅限于该语句块。 (2)修饰全局变量 对于一个全局变量，它既可以在本源文件中被访问到，也可以在同一个工程的其它源文件中被访问(只需用extern进行声明即可)。用static对全局变量进行修饰改变了其作用域的范围，由原来的整个工程可见变为本源文件可见。 (3)修饰函数 用static修饰函数的话，情况与修饰全局变量大同小异，就是改变了函数的作用域。 (4)C&#43;&#43;中的static 如果在C&#43;&#43;中对类中的某个函数用static进行修饰，则表示该函数属于一个类而不是属于此类的任何特定对象；如果对类中的某个变量进行static修饰，表示该变量为类以及其所有的对象所有。它们在存储空间中都只存在一个副本。可以通过类和对象去调用。 const 的含义及实现机制
const名叫常量限定符，用来限定特定变量，以通知编译器该变量是不可修改的。习惯性的使用const，可以避免在函数中对某些不应修改的变量造成可能的改动。 (1)const修饰基本数据类型 1.const修饰一般常量及数组 基本数据类型，修饰符const可以用在类型说明符前，也可以用在类型说明符后，其结果是一样的。在使用这些常量的时候，只要不改变这些常量的值便好。 2.const修饰指针变量*及引用变量&amp; 如果const位于星号*的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量； 如果const位于星号的右侧，const就是修饰指针本身，即指针本身是常量。 (2)const应用到函数中, 1.作为参数的const修饰符 调用函数的时候，用相应的变量初始化const常量，则在函数体中，按照const所修饰的部分进行常量化,保护了原对象的属性。 [注意]：参数const通常用于参数为指针或引用的情况; 2.作为函数返回值的const修饰符 声明了返回值后，const按照&#34;修饰原则&#34;进行修饰，起到相应的保护作用。 (3)const在类中的用法 不能在类声明中初始化const数据成员。正确的使用const实现方法为：const数据成员的初始化只能在类构造函数的初始化表中进行 类中的成员函数：A fun4()const; 其意义上是不能修改所在类的的任何变量。 (4)const修饰类对象，定义常量对象 常量对象只能调用常量函数，别的成员函数都不能调用。 http://www.cnblogs.com/wintergrass/archive/2011/04/15/2015020.html extern
在C语言中，修饰符extern用在变量或者函数的声明前，用来说明“此变量/函数是在别处定义的，要在此处引用”。 注意extern声明的位置对其作用域也有关系，如果是在main函数中进行声明的，则只能在main函数中调用，在其它函数中不能调用。其实要调用其它文件中的函数和变量，只需把该文件用#include包含进来即可，为啥要用extern？因为用extern会加速程序的编译过程，这样能节省时间。 在C&#43;&#43;中extern还有另外一种作用，用于指示C或者C＋＋函数的调用规范。比如在C＋＋中调用C库函数，就需要在C＋＋程序中用extern “C”声明要引用的函数。这是给链接器用的，告诉链接器在链接的时候用C函数规范来链接。主要原因是C＋＋和C程序编译完成后在目标代码中命名规则不同，用此来解决名字匹配的问题。 宏定义和展开、内联函数区别，
内联函数是代码被插入到调用者代码处的函数。如同 #define 宏，内联函数通过避免被调用的开销来提高执行效率，尤其是它能够通过调用（“过程化集成”）被编译器优化。 宏定义不检查函数参数，返回值什么的，只是展开，相对来说，内联函数会检查参数类型，所以更安全。	内联函数和宏很类似，而区别在于，宏是由预处理器对宏进行替代，而内联函数是通过编译器控制来实现的。而且内联函数是真正的函数，只是在需要用到的时候，内联函数像宏一样的展开，所以取消了函数的参数压栈，减少了调用的开销。 宏是预编译器的输入，然后宏展开之后的结果会送去编译器做语法分析。宏与函数等处于不同的级别，操作不同的实体。宏操作的是 token, 可以进行 token的替换和连接等操作，在语法分析之前起作用。而函数是语言中的概念，会在语法树中创建对应的实体，内联只是函数的一个属性。 对于问题：有了函数要它们何用？答案是：一：函数并不能完全替代宏，有些宏可以在当前作用域生成一些变量，函数做不到。二：内联函数只是函数的一种，内联是给编译器的提示，告诉它最好把这个函数在被调用处展开，省掉一个函数调用的开销（压栈，跳转，返回） 内联函数也有一定的局限性。就是函数中的执行代码不能太多了，如果，内联函数的函数体过大，一般的编译器会放弃内联方式，而采用普通的方式调用函数。这样，内联函数就和普通函数执行效率一样 内联函数必须是和函数体申明在一起，才有效。 [宏定义和内联函数区别](http://www.cnblogs.com/chengxuyuancc/archive/2013/04/04/2999844.html) 库函数实现： malloc,strcpy,strcmp 的实现，常用库函数实现，哪些库函数属于高危函数...</p>
  </div>
  <footer class="entry-footer"><span title='2022-03-27 22:59:11 +0800 +0800'>March 27, 2022</span></footer>
  <a class="entry-link" aria-label="post link to 后端开发面试题" href="https://xhwhis.github.io/hugo-blog/posts/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>数据库面试点<sup><span class="entry-isdraft">&nbsp;&nbsp;[draft]</span></sup>
    </h2>
  </header>
  <div class="entry-content">
    <p>数据库面试点 事务 4 个，acid（实现） 隔离操作 binlog、redolog、ondolog innodbe 和 myisim 掌握 三个特性（双次写、插入缓存、自适应） 锁 mvcc（乐观锁、悲观锁） 行锁（行锁、零件锁、间隙锁） 表锁 索引 数据结构（B&#43;树、B 树、Hash 索引、全文本索引） 逻辑结构（主键、唯一、前缀、覆盖、联合、普通） 存储结构（聚集索引（innodbe）、排序索引（myisim））） 索引失效、索引优化、索引下推、索引回表 最左匹配 查询优化 小表匹配大表（in exist） 小表—&gt;大表 order by group by 类型优化 分区分库分表、主从复制 </p>
  </div>
  <footer class="entry-footer"><span title='2022-03-27 22:59:11 +0800 +0800'>March 27, 2022</span></footer>
  <a class="entry-link" aria-label="post link to 数据库面试点" href="https://xhwhis.github.io/hugo-blog/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E7%82%B9/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>类和对象1<sup><span class="entry-isdraft">&nbsp;&nbsp;[draft]</span></sup>
    </h2>
  </header>
  <div class="entry-content">
    <p>类和对象 类型与变量 类型 变量 int a long long b char c double d float e 类型 = 类型数据 &#43; 类型操作
类与对象 类 对象 cat garfield dog odie people hug 访问权限 public 公共访问权限 private 私有访问权限 protected 受保护的访问权限 成员属性与方法 #include &lt;iostream&gt; using namespace std; struct A { int x, y; void echo() { cout &lt;&lt; &#34;hello world a&#34; &lt;&lt; endl; return ; } }; struct B { private: int x, y; public: void set_xy(int x, int y) { cout &lt;&lt; this &lt;&lt; endl; this-&gt;x = x, this-&gt;y = y; } void echo() { cout &lt;&lt; &#34;hello world b&#34; &lt;&lt; endl; cout &lt;&lt; x &lt;&lt; &#34; &#34; &lt;&lt; y &lt;&lt; endl; return ; } }; int main() { A a; B b; a....</p>
  </div>
  <footer class="entry-footer"><span title='2022-03-27 22:59:11 +0800 +0800'>March 27, 2022</span></footer>
  <a class="entry-link" aria-label="post link to 类和对象1" href="https://xhwhis.github.io/hugo-blog/posts/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A11/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>类和对象2<sup><span class="entry-isdraft">&nbsp;&nbsp;[draft]</span></sup>
    </h2>
  </header>
  <div class="entry-content">
    <p>类和对象 类属性与类方法 #include &lt;iostream&gt; using namespace std; class A { public : A(int x) { cout &lt;&lt; &#34;class A&#39;s constructor&#34; &lt;&lt; endl; } }; class Point { public : Point(); Point(int x, int y); int x() const; int y() const; int x_cnt() const; void set_x(int x); void set_y(int y); static int output_cnt(); ~Point(); private : static int point_cnt; int __x, __y; mutable int __x_cnt; A __a; }; int Point::point_cnt = 0; int Point::output_cnt() { return Point::point_cnt; } Point::Point() : __x_cnt(0), __a(2) { Point::point_cnt &#43;= 1; } Point::Point(int x, int y) : __x(x), __y(y), __x_cnt(0), __a(4) { Point::point_cnt &#43;= 1; } Point::~Point() { Point::point_cnt -= 1; } int Point::x() const { this-&gt;__x_cnt &#43;= 1; return this-&gt;__x; } int Point::y() const { return this-&gt;__y; } int Point::x_cnt() const { return this-&gt;__x_cnt; } void Point::set_x(int x) { this-&gt;__x = x; } void Point::set_y(int y) { this-&gt;__x = y; } void func() { Point c, d; cout &lt;&lt; &#34;func : &#34; &lt;&lt; Point::output_cnt() &lt;&lt; endl; return ; } int main() { Point a(2, 3), b; const Point c(3, 4); cout &lt;&lt; a....</p>
  </div>
  <footer class="entry-footer"><span title='2022-03-27 22:59:11 +0800 +0800'>March 27, 2022</span></footer>
  <a class="entry-link" aria-label="post link to 类和对象2" href="https://xhwhis.github.io/hugo-blog/posts/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A12/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="https://xhwhis.github.io/hugo-blog/posts/page/2/">
      «&nbsp;Prev&nbsp;
    </a>
    <a class="next" href="https://xhwhis.github.io/hugo-blog/posts/page/4/">Next&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
    <span>&copy; 2022 <a href="https://xhwhis.github.io/hugo-blog/">Whis&#39;s Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
