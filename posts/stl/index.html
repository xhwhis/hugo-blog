<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>STL | Whis&#39;s Blog</title>
<meta name="keywords" content="">
<meta name="description" content="Interview Q&amp;A STL B 树（B-tree）、B&#43; 树（B&#43;-tree） 特点 一般化的二叉查找树（binary search tree） “矮胖”，内部（非叶子）节点可以拥有可变数量的子节点（数量范围预先定义好） 应用 大部分文件系统、数据库系统都采用 B 树、B&#43;树作为索引结构 区别 B&#43;树中只有叶子节点会带有指向记录的指针（ROWID），而 B 树则所有节点都带有，在内部节点出现的索引项不会再出现在叶子节点。 B&#43;树中所有叶子节点都是通过指针连接在一起，而 B 树不会。 B 树的优点 对于在内部节点的数据，可直接得到，不必根据叶子节点来定位。 B&#43;树的优点 非叶子节点不会带上 ROWID，这样，一个块中可以容纳更多的索引项，一是可以降低树的高度。二是一个内部节点可以定位更多的叶子节点。 叶子节点之间通过指针来连接，范围扫描将十分简单，而对于 B 树来说，则需要在叶子节点和内部节点不停的往返移动。 STL 容器 容器 底层数据结构 时间复杂度 有无序 可不可重复 其他 array 数组 随机读改 O(1) 无序 可重复 支持随机访问 vector 数组 随机读改、尾部插入、尾部删除 O(1) 头部插入、头部删除 O(n) 无序 可重复 支持随机访问 deque 双端队列 头尾插入、头尾删除 O(1) 无序 可重复 一个中央控制器 &#43; 多个缓冲区，支持首尾快速增删，支持随机访问 forward_list 单向链表 插入、删除 O(1) 无序 可重复 不支持随机访问 list 双向链表 插入、删除 O(1) 无序 可重复 不支持随机访问 stack deque / list 顶部插入、顶部删除 O(1) 无序 可重复 deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时 queue deque / list 尾部插入、头部删除 O(1) 无序 可重复 deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时 priority_queue vector &#43; max-heap 插入、删除 O(log2n) 有序 可重复 vector 容器&#43;heap 处理规则 set 红黑树 插入、删除、查找 O(log2n) 有序 不可重复 multiset 红黑树 插入、删除、查找 O(log2n) 有序 可重复 map 红黑树 插入、删除、查找 O(log2n) 有序 不可重复 multimap 红黑树 插入、删除、查找 O(log2n) 有序 可重复 unordered_set 哈希表 插入、删除、查找 O(1) 最差 O(n) 无序 不可重复 unordered_multiset 哈希表 插入、删除、查找 O(1) 最差 O(n) 无序 可重复 unordered_map 哈希表 插入、删除、查找 O(1) 最差 O(n) 无序 不可重复 unordered_multimap 哈希表 插入、删除、查找 O(1) 最差 O(n) 无序 可重复 ">
<meta name="author" content="">
<link rel="canonical" href="https://xhwhis.github.io/hugo-blog/posts/stl/">
<link crossorigin="anonymous" href="/hugo-blog/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css" integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/hugo-blog/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://xhwhis.github.io/hugo-blog/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://xhwhis.github.io/hugo-blog/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://xhwhis.github.io/hugo-blog/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://xhwhis.github.io/hugo-blog/apple-touch-icon.png">
<link rel="mask-icon" href="https://xhwhis.github.io/hugo-blog/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="STL" />
<meta property="og:description" content="Interview Q&amp;A STL B 树（B-tree）、B&#43; 树（B&#43;-tree） 特点 一般化的二叉查找树（binary search tree） “矮胖”，内部（非叶子）节点可以拥有可变数量的子节点（数量范围预先定义好） 应用 大部分文件系统、数据库系统都采用 B 树、B&#43;树作为索引结构 区别 B&#43;树中只有叶子节点会带有指向记录的指针（ROWID），而 B 树则所有节点都带有，在内部节点出现的索引项不会再出现在叶子节点。 B&#43;树中所有叶子节点都是通过指针连接在一起，而 B 树不会。 B 树的优点 对于在内部节点的数据，可直接得到，不必根据叶子节点来定位。 B&#43;树的优点 非叶子节点不会带上 ROWID，这样，一个块中可以容纳更多的索引项，一是可以降低树的高度。二是一个内部节点可以定位更多的叶子节点。 叶子节点之间通过指针来连接，范围扫描将十分简单，而对于 B 树来说，则需要在叶子节点和内部节点不停的往返移动。 STL 容器 容器 底层数据结构 时间复杂度 有无序 可不可重复 其他 array 数组 随机读改 O(1) 无序 可重复 支持随机访问 vector 数组 随机读改、尾部插入、尾部删除 O(1) 头部插入、头部删除 O(n) 无序 可重复 支持随机访问 deque 双端队列 头尾插入、头尾删除 O(1) 无序 可重复 一个中央控制器 &#43; 多个缓冲区，支持首尾快速增删，支持随机访问 forward_list 单向链表 插入、删除 O(1) 无序 可重复 不支持随机访问 list 双向链表 插入、删除 O(1) 无序 可重复 不支持随机访问 stack deque / list 顶部插入、顶部删除 O(1) 无序 可重复 deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时 queue deque / list 尾部插入、头部删除 O(1) 无序 可重复 deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时 priority_queue vector &#43; max-heap 插入、删除 O(log2n) 有序 可重复 vector 容器&#43;heap 处理规则 set 红黑树 插入、删除、查找 O(log2n) 有序 不可重复 multiset 红黑树 插入、删除、查找 O(log2n) 有序 可重复 map 红黑树 插入、删除、查找 O(log2n) 有序 不可重复 multimap 红黑树 插入、删除、查找 O(log2n) 有序 可重复 unordered_set 哈希表 插入、删除、查找 O(1) 最差 O(n) 无序 不可重复 unordered_multiset 哈希表 插入、删除、查找 O(1) 最差 O(n) 无序 可重复 unordered_map 哈希表 插入、删除、查找 O(1) 最差 O(n) 无序 不可重复 unordered_multimap 哈希表 插入、删除、查找 O(1) 最差 O(n) 无序 可重复 " />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://xhwhis.github.io/hugo-blog/posts/stl/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-27T22:59:11+08:00" />
<meta property="article:modified_time" content="2022-03-27T22:59:11+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="STL"/>
<meta name="twitter:description" content="Interview Q&amp;A STL B 树（B-tree）、B&#43; 树（B&#43;-tree） 特点 一般化的二叉查找树（binary search tree） “矮胖”，内部（非叶子）节点可以拥有可变数量的子节点（数量范围预先定义好） 应用 大部分文件系统、数据库系统都采用 B 树、B&#43;树作为索引结构 区别 B&#43;树中只有叶子节点会带有指向记录的指针（ROWID），而 B 树则所有节点都带有，在内部节点出现的索引项不会再出现在叶子节点。 B&#43;树中所有叶子节点都是通过指针连接在一起，而 B 树不会。 B 树的优点 对于在内部节点的数据，可直接得到，不必根据叶子节点来定位。 B&#43;树的优点 非叶子节点不会带上 ROWID，这样，一个块中可以容纳更多的索引项，一是可以降低树的高度。二是一个内部节点可以定位更多的叶子节点。 叶子节点之间通过指针来连接，范围扫描将十分简单，而对于 B 树来说，则需要在叶子节点和内部节点不停的往返移动。 STL 容器 容器 底层数据结构 时间复杂度 有无序 可不可重复 其他 array 数组 随机读改 O(1) 无序 可重复 支持随机访问 vector 数组 随机读改、尾部插入、尾部删除 O(1) 头部插入、头部删除 O(n) 无序 可重复 支持随机访问 deque 双端队列 头尾插入、头尾删除 O(1) 无序 可重复 一个中央控制器 &#43; 多个缓冲区，支持首尾快速增删，支持随机访问 forward_list 单向链表 插入、删除 O(1) 无序 可重复 不支持随机访问 list 双向链表 插入、删除 O(1) 无序 可重复 不支持随机访问 stack deque / list 顶部插入、顶部删除 O(1) 无序 可重复 deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时 queue deque / list 尾部插入、头部删除 O(1) 无序 可重复 deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时 priority_queue vector &#43; max-heap 插入、删除 O(log2n) 有序 可重复 vector 容器&#43;heap 处理规则 set 红黑树 插入、删除、查找 O(log2n) 有序 不可重复 multiset 红黑树 插入、删除、查找 O(log2n) 有序 可重复 map 红黑树 插入、删除、查找 O(log2n) 有序 不可重复 multimap 红黑树 插入、删除、查找 O(log2n) 有序 可重复 unordered_set 哈希表 插入、删除、查找 O(1) 最差 O(n) 无序 不可重复 unordered_multiset 哈希表 插入、删除、查找 O(1) 最差 O(n) 无序 可重复 unordered_map 哈希表 插入、删除、查找 O(1) 最差 O(n) 无序 不可重复 unordered_multimap 哈希表 插入、删除、查找 O(1) 最差 O(n) 无序 可重复 "/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://xhwhis.github.io/hugo-blog/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "STL",
      "item": "https://xhwhis.github.io/hugo-blog/posts/stl/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "STL",
  "name": "STL",
  "description": "Interview Q\u0026amp;A STL B 树（B-tree）、B+ 树（B+-tree） 特点 一般化的二叉查找树（binary search tree） “矮胖”，内部（非叶子）节点可以拥有可变数量的子节点（数量范围预先定义好） 应用 大部分文件系统、数据库系统都采用 B 树、B+树作为索引结构 区别 B+树中只有叶子节点会带有指向记录的指针（ROWID），而 B 树则所有节点都带有，在内部节点出现的索引项不会再出现在叶子节点。 B+树中所有叶子节点都是通过指针连接在一起，而 B 树不会。 B 树的优点 对于在内部节点的数据，可直接得到，不必根据叶子节点来定位。 B+树的优点 非叶子节点不会带上 ROWID，这样，一个块中可以容纳更多的索引项，一是可以降低树的高度。二是一个内部节点可以定位更多的叶子节点。 叶子节点之间通过指针来连接，范围扫描将十分简单，而对于 B 树来说，则需要在叶子节点和内部节点不停的往返移动。 STL 容器 容器 底层数据结构 时间复杂度 有无序 可不可重复 其他 array 数组 随机读改 O(1) 无序 可重复 支持随机访问 vector 数组 随机读改、尾部插入、尾部删除 O(1) 头部插入、头部删除 O(n) 无序 可重复 支持随机访问 deque 双端队列 头尾插入、头尾删除 O(1) 无序 可重复 一个中央控制器 + 多个缓冲区，支持首尾快速增删，支持随机访问 forward_list 单向链表 插入、删除 O(1) 无序 可重复 不支持随机访问 list 双向链表 插入、删除 O(1) 无序 可重复 不支持随机访问 stack deque / list 顶部插入、顶部删除 O(1) 无序 可重复 deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时 queue deque / list 尾部插入、头部删除 O(1) 无序 可重复 deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时 priority_queue vector + max-heap 插入、删除 O(log2n) 有序 可重复 vector 容器+heap 处理规则 set 红黑树 插入、删除、查找 O(log2n) 有序 不可重复 multiset 红黑树 插入、删除、查找 O(log2n) 有序 可重复 map 红黑树 插入、删除、查找 O(log2n) 有序 不可重复 multimap 红黑树 插入、删除、查找 O(log2n) 有序 可重复 unordered_set 哈希表 插入、删除、查找 O(1) 最差 O(n) 无序 不可重复 unordered_multiset 哈希表 插入、删除、查找 O(1) 最差 O(n) 无序 可重复 unordered_map 哈希表 插入、删除、查找 O(1) 最差 O(n) 无序 不可重复 unordered_multimap 哈希表 插入、删除、查找 O(1) 最差 O(n) 无序 可重复 ",
  "keywords": [
    
  ],
  "articleBody": "Interview Q\u0026A STL B 树（B-tree）、B+ 树（B+-tree） 特点 一般化的二叉查找树（binary search tree） “矮胖”，内部（非叶子）节点可以拥有可变数量的子节点（数量范围预先定义好） 应用 大部分文件系统、数据库系统都采用 B 树、B+树作为索引结构 区别 B+树中只有叶子节点会带有指向记录的指针（ROWID），而 B 树则所有节点都带有，在内部节点出现的索引项不会再出现在叶子节点。 B+树中所有叶子节点都是通过指针连接在一起，而 B 树不会。 B 树的优点 对于在内部节点的数据，可直接得到，不必根据叶子节点来定位。 B+树的优点 非叶子节点不会带上 ROWID，这样，一个块中可以容纳更多的索引项，一是可以降低树的高度。二是一个内部节点可以定位更多的叶子节点。 叶子节点之间通过指针来连接，范围扫描将十分简单，而对于 B 树来说，则需要在叶子节点和内部节点不停的往返移动。 STL 容器 容器 底层数据结构 时间复杂度 有无序 可不可重复 其他 array 数组 随机读改 O(1) 无序 可重复 支持随机访问 vector 数组 随机读改、尾部插入、尾部删除 O(1) 头部插入、头部删除 O(n) 无序 可重复 支持随机访问 deque 双端队列 头尾插入、头尾删除 O(1) 无序 可重复 一个中央控制器 + 多个缓冲区，支持首尾快速增删，支持随机访问 forward_list 单向链表 插入、删除 O(1) 无序 可重复 不支持随机访问 list 双向链表 插入、删除 O(1) 无序 可重复 不支持随机访问 stack deque / list 顶部插入、顶部删除 O(1) 无序 可重复 deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时 queue deque / list 尾部插入、头部删除 O(1) 无序 可重复 deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时 priority_queue vector + max-heap 插入、删除 O(log2n) 有序 可重复 vector 容器+heap 处理规则 set 红黑树 插入、删除、查找 O(log2n) 有序 不可重复 multiset 红黑树 插入、删除、查找 O(log2n) 有序 可重复 map 红黑树 插入、删除、查找 O(log2n) 有序 不可重复 multimap 红黑树 插入、删除、查找 O(log2n) 有序 可重复 unordered_set 哈希表 插入、删除、查找 O(1) 最差 O(n) 无序 不可重复 unordered_multiset 哈希表 插入、删除、查找 O(1) 最差 O(n) 无序 可重复 unordered_map 哈希表 插入、删除、查找 O(1) 最差 O(n) 无序 不可重复 unordered_multimap 哈希表 插入、删除、查找 O(1) 最差 O(n) 无序 可重复 ",
  "wordCount" : "173",
  "inLanguage": "en",
  "datePublished": "2022-03-27T22:59:11+08:00",
  "dateModified": "2022-03-27T22:59:11+08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://xhwhis.github.io/hugo-blog/posts/stl/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Whis's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://xhwhis.github.io/hugo-blog/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://xhwhis.github.io/hugo-blog/" accesskey="h" title="Whis&#39;s Blog (Alt + H)">Whis&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      STL<sup><span class="entry-isdraft">&nbsp;&nbsp;[draft]</span></sup>
    </h1>
    <div class="post-meta"><span title='2022-03-27 22:59:11 +0800 +0800'>March 27, 2022</span>

</div>
  </header> 
  <div class="post-content"><h1 id="interview-qa-stl">Interview Q&amp;A STL<a hidden class="anchor" aria-hidden="true" href="#interview-qa-stl">#</a></h1>
<h2 id="b-树b-treeb-树b-tree">B 树（B-tree）、B+ 树（B+-tree）<a hidden class="anchor" aria-hidden="true" href="#b-树b-treeb-树b-tree">#</a></h2>
<h3 id="特点">特点<a hidden class="anchor" aria-hidden="true" href="#特点">#</a></h3>
<ul>
<li>一般化的二叉查找树（binary search tree）</li>
<li>“矮胖”，内部（非叶子）节点可以拥有可变数量的子节点（数量范围预先定义好）</li>
</ul>
<h3 id="应用">应用<a hidden class="anchor" aria-hidden="true" href="#应用">#</a></h3>
<ul>
<li>大部分文件系统、数据库系统都采用 B 树、B+树作为索引结构</li>
</ul>
<h3 id="区别">区别<a hidden class="anchor" aria-hidden="true" href="#区别">#</a></h3>
<ul>
<li>B+树中只有叶子节点会带有指向记录的指针（ROWID），而 B 树则所有节点都带有，在内部节点出现的索引项不会再出现在叶子节点。</li>
<li>B+树中所有叶子节点都是通过指针连接在一起，而 B 树不会。</li>
</ul>
<h3 id="b-树的优点">B 树的优点<a hidden class="anchor" aria-hidden="true" href="#b-树的优点">#</a></h3>
<ul>
<li>对于在内部节点的数据，可直接得到，不必根据叶子节点来定位。</li>
</ul>
<h3 id="b树的优点">B+树的优点<a hidden class="anchor" aria-hidden="true" href="#b树的优点">#</a></h3>
<ul>
<li>非叶子节点不会带上 ROWID，这样，一个块中可以容纳更多的索引项，一是可以降低树的高度。二是一个内部节点可以定位更多的叶子节点。</li>
<li>叶子节点之间通过指针来连接，范围扫描将十分简单，而对于 B 树来说，则需要在叶子节点和内部节点不停的往返移动。</li>
</ul>
<h2 id="stl-容器">STL 容器<a hidden class="anchor" aria-hidden="true" href="#stl-容器">#</a></h2>
<table>
<thead>
<tr>
<th>容器</th>
<th>底层数据结构</th>
<th>时间复杂度</th>
<th>有无序</th>
<th>可不可重复</th>
<th>其他</th>
</tr>
</thead>
<tbody>
<tr>
<td>array</td>
<td>数组</td>
<td>随机读改 O(1)</td>
<td>无序</td>
<td>可重复</td>
<td>支持随机访问</td>
</tr>
<tr>
<td>vector</td>
<td>数组</td>
<td>随机读改、尾部插入、尾部删除 O(1) 头部插入、头部删除 O(n)</td>
<td>无序</td>
<td>可重复</td>
<td>支持随机访问</td>
</tr>
<tr>
<td>deque</td>
<td>双端队列</td>
<td>头尾插入、头尾删除 O(1)</td>
<td>无序</td>
<td>可重复</td>
<td>一个中央控制器 + 多个缓冲区，支持首尾快速增删，支持随机访问</td>
</tr>
<tr>
<td>forward_list</td>
<td>单向链表</td>
<td>插入、删除 O(1)</td>
<td>无序</td>
<td>可重复</td>
<td>不支持随机访问</td>
</tr>
<tr>
<td>list</td>
<td>双向链表</td>
<td>插入、删除 O(1)</td>
<td>无序</td>
<td>可重复</td>
<td>不支持随机访问</td>
</tr>
<tr>
<td>stack</td>
<td>deque / list</td>
<td>顶部插入、顶部删除 O(1)</td>
<td>无序</td>
<td>可重复</td>
<td>deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时</td>
</tr>
<tr>
<td>queue</td>
<td>deque / list</td>
<td>尾部插入、头部删除 O(1)</td>
<td>无序</td>
<td>可重复</td>
<td>deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时</td>
</tr>
<tr>
<td>priority_queue</td>
<td>vector + max-heap</td>
<td>插入、删除 O(log2n)</td>
<td>有序</td>
<td>可重复</td>
<td>vector 容器+heap 处理规则</td>
</tr>
<tr>
<td>set</td>
<td>红黑树</td>
<td>插入、删除、查找 O(log2n)</td>
<td>有序</td>
<td>不可重复</td>
<td></td>
</tr>
<tr>
<td>multiset</td>
<td>红黑树</td>
<td>插入、删除、查找 O(log2n)</td>
<td>有序</td>
<td>可重复</td>
<td></td>
</tr>
<tr>
<td>map</td>
<td>红黑树</td>
<td>插入、删除、查找 O(log2n)</td>
<td>有序</td>
<td>不可重复</td>
<td></td>
</tr>
<tr>
<td>multimap</td>
<td>红黑树</td>
<td>插入、删除、查找 O(log2n)</td>
<td>有序</td>
<td>可重复</td>
<td></td>
</tr>
<tr>
<td>unordered_set</td>
<td>哈希表</td>
<td>插入、删除、查找 O(1) 最差 O(n)</td>
<td>无序</td>
<td>不可重复</td>
<td></td>
</tr>
<tr>
<td>unordered_multiset</td>
<td>哈希表</td>
<td>插入、删除、查找 O(1) 最差 O(n)</td>
<td>无序</td>
<td>可重复</td>
<td></td>
</tr>
<tr>
<td>unordered_map</td>
<td>哈希表</td>
<td>插入、删除、查找 O(1) 最差 O(n)</td>
<td>无序</td>
<td>不可重复</td>
<td></td>
</tr>
<tr>
<td>unordered_multimap</td>
<td>哈希表</td>
<td>插入、删除、查找 O(1) 最差 O(n)</td>
<td>无序</td>
<td>可重复</td>
<td></td>
</tr>
</tbody>
</table>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2022 <a href="https://xhwhis.github.io/hugo-blog/">Whis&#39;s Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
